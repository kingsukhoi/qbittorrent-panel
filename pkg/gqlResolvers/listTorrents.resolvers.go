package gqlResolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"slices"
	"strings"

	"github.com/kingsukhoi/qbitorrent-panel/pkg/gqlGenerated"
	"github.com/kingsukhoi/qbitorrent-panel/pkg/helpers"
	"github.com/kingsukhoi/qbitorrent-panel/pkg/qbClient"
)

// Torrents is the resolver for the Torrents field.
func (r *queryResolver) Torrents(ctx context.Context, categories []string, servers []string) ([]gqlGenerated.Torrent, error) {
	var qbClients []*qbClient.Client

	if len(servers) == 0 {
		qbClients = qbClient.Registry().All()
	} else {
		for _, client := range servers {
			curr, exist := qbClient.Registry().Get(client)
			if !exist {
				return nil, fmt.Errorf("client %s does not exist", client)
			}
			qbClients = append(qbClients, curr)
		}
	}

	rtnMe := make([]gqlGenerated.Torrent, 0)

	for _, client := range qbClients {
		torrents, errL := client.GetTorrents(ctx)
		if errL != nil {
			return nil, errL
		}

		for _, torrent := range torrents {
			match := slices.Contains(categories, torrent.Category)
			if !match && len(categories) > 0 {
				continue
			}

			curr := gqlGenerated.Torrent{
				Server:     torrent.Client.BasePath.String(),
				Name:       torrent.Name,
				Category:   torrent.Category,
				Ratio:      torrent.Ratio,
				InfoHashV1: torrent.InfohashV1,
				Comment:    torrent.Comment,
				RootPath:   torrent.RootPath,
				SavePath:   torrent.SavePath,
				SizeBytes:  torrent.Size,
				Tracker:    torrent.Tracker,
			}
			rtnMe = append(rtnMe, curr)
		}
	}

	slices.SortFunc(rtnMe, func(a, b gqlGenerated.Torrent) int {
		return strings.Compare(a.Server, b.Server)
	})

	return rtnMe, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]gqlGenerated.Category, error) {
	categories, err := helpers.GetAllCategories(ctx)
	if err != nil {
		return nil, err
	}

	rtnMe := make([]gqlGenerated.Category, 0)

	for _, category := range categories {
		rtnMe = append(rtnMe, gqlGenerated.Category{
			Name:    category.Name,
			Path:    category.SavePath,
			Servers: category.Servers,
		})
	}

	slices.SortFunc(rtnMe, func(a, b gqlGenerated.Category) int {
		return strings.Compare(a.Name, b.Name)
	})

	return rtnMe, nil
}

// Torrent is the resolver for the Torrent field.
func (r *queryResolver) Torrent(ctx context.Context, infoHashV1 string) ([]*gqlGenerated.Torrent, error) {
	clients := qbClient.Registry().All()

	rtnMe := make([]*gqlGenerated.Torrent, 0)

	for _, client := range clients {
		torrent, errL := client.GetTorrent(ctx, infoHashV1)
		if errL != nil {
			if errors.Is(errL, qbClient.TorrentNotFoundError) {
				continue
			} else {
				return nil, errL
			}
		}

		rtnMe = append(rtnMe, &gqlGenerated.Torrent{
			Server:     client.BasePath.String(),
			Name:       torrent.Name,
			Category:   torrent.Category,
			Ratio:      torrent.Ratio,
			InfoHashV1: torrent.InfohashV1,
			Comment:    torrent.Comment,
			RootPath:   torrent.RootPath,
			SavePath:   torrent.SavePath,
			SizeBytes:  torrent.Size,
			Tracker:    torrent.Tracker,
		})
	}

	if len(rtnMe) == 0 {
		return nil, errors.New("torrent not found")
	}
	return rtnMe, nil
}

// Files is the resolver for the Files field.
func (r *torrentResolver) Files(ctx context.Context, obj *gqlGenerated.Torrent) ([]gqlGenerated.File, error) {
	client, exist := qbClient.Registry().Get(obj.Server)

	if !exist {
		return nil, fmt.Errorf("client not found")
	}

	files, err := client.GetFilesInTorrent(ctx, obj.InfoHashV1)
	if err != nil {
		return nil, err
	}

	rtnMe := make([]gqlGenerated.File, 0)

	for _, file := range files {
		curr := gqlGenerated.File{
			Availability: file.Availability,
			Index:        file.Index,
			IsSeed:       file.IsSeed,
			Name:         file.Name,
			PieceRange:   file.PieceRange,
			Priority:     file.Priority,
			Progress:     file.Progress,
			SizeBytes:    file.Size,
		}
		rtnMe = append(rtnMe, curr)
	}
	if len(rtnMe) == 0 {
		return nil, errors.New("no files found")
	}

	return rtnMe, nil
}

// Query returns gqlGenerated.QueryResolver implementation.
func (r *Resolver) Query() gqlGenerated.QueryResolver { return &queryResolver{r} }

// Torrent returns gqlGenerated.TorrentResolver implementation.
func (r *Resolver) Torrent() gqlGenerated.TorrentResolver { return &torrentResolver{r} }

type queryResolver struct{ *Resolver }
type torrentResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) TestNullable(ctx context.Context, input *string) (*gqlGenerated.Torrent, error) {
	panic(fmt.Errorf("not implemented: TestNullable - TestNullable"))
}
*/
